;; Library was created based on UCB Logo's

.macro localmake :name :value
output (list "local word "" :name "apply ""make (list :name :value))
end

.macro while :while.cond :while.instr
if not run :while.cond [op []]
op append :while.instr (list "while :while.cond :while.instr)
end

.macro do.while :while.instr :while.cond
op append :while.instr (list "while :while.cond :while.instr)
end

.macro until :until.cond :until.instr
if run :until.cond [op []]
op append :until.instr (list "until :until.cond :until.instr)
end

.macro do.until :until.instr :until.cond
op append :until.instr (list "until :until.cond :until.instr)
end

to ? [:index 1]
output item :index :template.inputs
end

to ?rest
output bf :values
end

to #
output :template.number
end

to for :values :instr
localmake "var first :values
local :var
localmake "initial run first butfirst :values
localmake "final run item 3 :values
localmake "step forstep
localmake "tester ifelse :step < 0 [[:value < :final]] [[:value > :final]]
forloop :initial
end

to forstep
if (count :values)=4 [output run last :values]
if :initial > :final [output -1]
output 1
end

to forloop :value
make :var :value
if run :tester [stop]
run :instr
forloop :value+:step
end

to foreach :values :template [:template.number 1]
if emptyp :values [stop]
apply :template (list first :values)
(foreach (butfirst :values) :template :template.number+1)
end

to firsts :list.of.lists
output map "first :list.of.lists
end

to butfirsts :list.of.lists
output map "butfirst :list.of.lists
end

to combine :this :those
if wordp :those [output word :this :those]
output fput :this :those
end

to map :template :values [:template.number 1]
if emptyp :values [output :values]
output combine (apply :template (list first :values)) ~
               (map :template butfirst :values :template.number+1)
end

to map.se :template :values [:template.number 1]
if emptyp :values [output []]
output sentence (apply :template (list first :values)) ~
                (map.se :template butfirst :values :template.number+1)
end

to map.append :template :values [:template.number 1]
if emptyp :values [output []]
output append (apply :template (list first :values)) ~
              (map.append :template butfirst :values :template.number+1)
end

to filter :template :values [:template.number 1]
if emptyp :values [output :values]
if apply :template (list first :values) ~
   [output combine (first :values) ~
                   (filter :template bf :values :template.number+1)]
output (filter :template bf :values :template.number+1)
end

to reduce :template :values
if emptyp bf :values [output first :values]
output apply :template (list (first :values) ~
                             (reduce :template bf :values))
end

to max :a :b
output ifelse :a > :b [:a] [:b]
end

to pick :list
output item (1+random count :list) :list
end

to map.tree :template :tree
if wordp :tree [output apply :template (list :tree)]
if emptyp :tree [output []]
output fput (map.tree :template first :tree) ~
            (map.tree :template bf :tree)
end

to lput :datum :list
output append :list (list :datum)
end

to crossmap :cm.template [:cm.lists] 2
if emptyp bf :cm.lists [op cm1 first :cm.lists 1 []]
op cm1 :cm.lists 1 []
end

to cm1 :cm.lists :cm.level :template.vars
if emptyp :cm.lists [op (list apply :cm.template :template.vars)]
op cm2 first :cm.lists
end

to cm2 :cm.thislist
if emptyp :cm.thislist [op []]
local :cm.level
make :cm.level first :cm.thislist
op se (cm1 bf :cm.lists :cm.level+1 lput first :cm.thislist :template.vars) ~
      (cm2 bf :cm.thislist)
end
